
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>Using Prepared Statements &#8212; Go database/sql tutorial  ドキュメント</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="エラーの扱い" href="errors.html" />
    <link rel="prev" title="Modifying Data and Using Transactions" href="modifying.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="using-prepared-statements">
<h1>Using Prepared Statements<a class="headerlink" href="#using-prepared-statements" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Goのプリペアードステートメントは、よく知られた利点(セキュリティ、効率性、利便性)はすべてあります。ただし、それらの実装方法は、特に <code class="docutils literal notranslate"><span class="pre">database/sql</span></code> の内部のやり取りに関して、よく知られているものとは少し異なるかもしれません。</p>
<div class="section" id="id1">
<h2>プリペアードステートメントとコネクション<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>データベースのレイヤーでは、プリペアードステートメントは単一のデータベース接続に紐付けられます。典型的な流れは、クライアントがプレースホルダ付きのSQLステートメントをサーバーに準備として送信します。サーバーからはステートメントIDがレスポンスとして返ってきて、クライアントはレスポンスIDとパラメータを送信することでステートメントを実行します。</p>
<p>しかしGoでは <code class="docutils literal notranslate"><span class="pre">database/sql</span></code> パッケージのユーザーには直接コネクションが公開されることはありません。接続に関するステートメントを準備する必要はありません。<code class="docutils literal notranslate"><span class="pre">DB</span></code> or a <code class="docutils literal notranslate"><span class="pre">Tx</span></code> を用いて準備します。そして <code class="docutils literal notranslate"><span class="pre">database/sql</span></code> は自動リトライなどのいくつかの便利な機能があります。これらの理由によってドライバーのレイヤで存在するプリペアードステートメントとコネクションの紐付けは、コードには表れません。</p>
<p>仕組みは次のとおりです。</p>
<ol class="arabic simple">
<li><p>ステートメントを準備すると、プールからコネクションが準備されます。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Stmt</span></code> オブジェクトはどのコネクションが使われているか把握します。</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Stmt</span></code> を実行すると、コネクションを使うように試行します。もしコネクションが閉じているか、別の何かの操作でビジーになっていて、コネクションが使用できない場合、プールから別のコネクションを取得し <em>別のコネクションでステートメントを再準備します</em> 。</p></li>
</ol>
<p>元のコネクションがビジーの場合、必要に応じてステートメントは再準備されます。多数の接続がビジー状態のままになるような高い並列度で使用することができ、たくさんのプリペアードステートメントを作成することができます。これにより、ステートメントのリークをもたらす可能性があります。予想よりも頻繁に再準備され、サーバー側ではステートメントの数が制限されることさえあります。</p>
</div>
<div class="section" id="id2">
<h2>プリペアードステートメントの回避<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Goは内部でプリペアードステートメントを作成します。簡単な例として <code class="docutils literal notranslate"><span class="pre">db.Query(sql,</span> <span class="pre">param1,</span> <span class="pre">param2)</span></code> はSQLを準備し、パラメータを受け取って実行され、ステートメントは閉じられることで機能します。</p>
<p>いくつかの場面で、プリペアードステートメントが必要でない場合もあります。以下の理由によるものです。</p>
<ol class="arabic simple">
<li><p>データベースがプリペアードステートメントをサポートしていない場合。例えばMySQLドライバーを使ってMemSQLやSphinxに接続することができますが、これはMySQLのWireプロトコルをサポートしているためです。しかしプリペアードステートメントを含む、&quot;バイナリ&quot; のプロトコルはサポートしていないため、わかりにくい理由で失敗することがあります。</p></li>
<li><p>ステートメントは再利用する価値がなく、セキュリティの問題は別の方法で扱われる場合です。プリペアードステートメントはパフォーマンスの観点で望ましくないためです。この例は <a class="reference external" href="https://vividcortex.com/blog/2014/11/19/analyzing-prepared-statement-performance-with-vividcortex/">VividCortex blog</a> で見ることができます。</p></li>
</ol>
<p>プリペアードステートメントを使用したくない場合は、<code class="docutils literal notranslate"><span class="pre">fmt.Sprint()</span></code> などを用いてSQLを組み立てる必要があり、<code class="docutils literal notranslate"><span class="pre">db.Query()</span></code> や <code class="docutils literal notranslate"><span class="pre">db.QueryRow()</span></code> に唯一の引数として渡す必要があります。またドライバーは素のテキストクエリの実行をサポートする必要があります。これはGo1.1で追加された <code class="docutils literal notranslate"><span class="pre">Execer</span></code> や <code class="docutils literal notranslate"><span class="pre">Queryer</span></code> インターフェースを実装します。詳細は <a class="reference external" href="http://golang.org/pkg/database/sql/driver/#Execer">documented here</a> を参照ください。</p>
</div>
<div class="section" id="id3">
<h2>トランザクション内でのプリペアードステートメント<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">Tx</span></code> 内で作成されたプリペアードステートメントは <code class="docutils literal notranslate"><span class="pre">Tx</span></code> のみに紐付いているため、再準備に関する以前の注意事項は適用されません。<code class="docutils literal notranslate"><span class="pre">Tx</span></code> オブジェクトを操作する場合、その操作はバックグラウンドの唯一のコネクションにのみ直接マッピングされます。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>訳を改善する。
<code class="docutils literal notranslate"><span class="pre">Tx</span></code> 内で作成されたプリペアードステートメントは <code class="docutils literal notranslate"><span class="pre">Tx</span></code> のみに紐付いているため、再準備に関する以前の注意事項は適用されません。
Prepared statements that are created in a <code class="docutils literal notranslate"><span class="pre">Tx</span></code> are bound exclusively to it, so the earlier cautions about repreparing do not apply.</p>
</div>
<p>これは <code class="docutils literal notranslate"><span class="pre">Tx</span></code> の中で作成されたプリペアードステートメントはそのトランザクションと分離して用いることができない、ということを意味します。同様に、<code class="docutils literal notranslate"><span class="pre">DB</span></code> で作成されたプリペアードステートメントはトランザクション内で使うことができません。<code class="docutils literal notranslate"><span class="pre">Tx</span></code> と <code class="docutils literal notranslate"><span class="pre">DB</span></code> はことなるコネクションに紐付いているためです。</p>
<p><code class="docutils literal notranslate"><span class="pre">Tx</span></code> でトランザクション外で準備されたプリペアードステートメントを使う場合、<code class="docutils literal notranslate"><span class="pre">Tx.Stmt()</span></code> を使うことができます。これによりトランザクション外で準備されたステートメントからトランザクション固有のステートメントが作成されます。これは既存のプリペアードステートメントを取得し、トランザクションのコネクションに設定し、実行されるたびにすべてのステートメントを再準備します。この動作と実装は望ましくなく、 <code class="docutils literal notranslate"><span class="pre">database/sql</span></code> のソースコードにも TODO があります。これを使用しないことを推奨します。</p>
<p>トランザクションでプリペアードステートメントを使う場合は注意が必要です。以下の例について考えてみましょう。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">tx</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">Begin</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Rollback</span><span class="p">()</span>
<span class="nx">stmt</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Prepare</span><span class="p">(</span><span class="s">&quot;INSERT INTO foo VALUES (?)&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">defer</span> <span class="nx">stmt</span><span class="p">.</span><span class="nx">Close</span><span class="p">()</span> <span class="c1">// danger!</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">stmt</span><span class="p">.</span><span class="nx">Exec</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">err</span> <span class="p">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Commit</span><span class="p">()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">log</span><span class="p">.</span><span class="nx">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// stmt.Close() runs here!</span>
</pre></div>
</div>
<p>Go1.4以前は <code class="docutils literal notranslate"><span class="pre">sql.Tx</span></code> をCloseするとそれに紐付いているコネクションを開放し、プールに戻します。しかしプリペアードステートメントでCloseを遅延呼び出しすることは、トランザクションが発生した <strong>後</strong> に実行されました。これはコネクションへの同時アクセスにつながり、接続状態に一貫性がありません。Go1.4以前のバージョンを使用する場合、トランザクションがコミットやロールバックされる前に、ステートメントが閉じられていることを確認する必要がありました。 <a class="reference external" href="https://github.com/golang/go/issues/4459">この問題</a> はGo1.4の <a class="reference external" href="https://codereview.appspot.com/131650043">CR 131650043</a> で修正されました。</p>
</div>
<div class="section" id="id5">
<h2>プレースホルダの構文<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>プリペアードステートメントで使われるパラメータのプレースホルダの構文はデータベース固有のものです。例としてMySQLとPostgreSQLとOracleを比較しています。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>MySQL               PostgreSQL            Oracle
=====               ==========            ======
WHERE col = ?       WHERE col = $1        WHERE col = :col
VALUES(?, ?, ?)     VALUES($1, $2, $3)    VALUES(:val1, :val2, :val3)
</pre></div>
</div>
<div class="line-block">
<div class="line">前に戻る: <a class="reference external" href="modifying.html">Modifying Data and Using Transactions</a></div>
<div class="line">次に進む: <a class="reference external" href="errors.html">Handling Errors</a></div>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div id="toc" class="sidebarRow">
    <h5>GO DATABASE/SQL TUTORIAL</h5>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="importing.html">Importing a Database Driver</a></li>
<li class="toctree-l1"><a class="reference internal" href="accessing.html">Accessing the Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="retrieving.html">Retrieving Result Sets</a></li>
<li class="toctree-l1"><a class="reference internal" href="modifying.html">Modifying Data and Using Transactions</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Using Prepared Statements</a></li>
<li class="toctree-l1"><a class="reference internal" href="errors.html">エラーの扱い</a></li>
<li class="toctree-l1"><a class="reference internal" href="nulls.html">Working with NULLs</a></li>
<li class="toctree-l1"><a class="reference internal" href="varcols.html">Working with Unknown Columns</a></li>
<li class="toctree-l1"><a class="reference internal" href="connection-pool.html">The Connection Pool</a></li>
<li class="toctree-l1"><a class="reference internal" href="surprises.html">Surprises, Antipatterns and Limitations</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">Related Reading and Resources</a></li>
</ul>

    
</div>

<style type="text/css">
    .toctree-l1 {
        font-size: 12px;
        margin-bottom: 0;
        font-stretch: normal;
        font-style: normal;
        line-height: 1.33;
        padding-bottom: 5px;
        margin: 2px;
    }
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;VividCortex (translated by @d-tsuji).
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/prepared.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>