========================================
驚き/アンチパターン/制限
========================================

---------------------------------

``database/sql`` は慣れれば簡単ですが、サポートするユースケースの微妙さに驚くかもしれません。これはGoのコアライブラリに共通です。

リソースの枯渇
===================

このサイト全体で言及したように、意図したとおりに ``database/sql`` を使用しない場合、通常はリソースを消費するか、リソースの効果的な再利用を妨げることにより、問題を引き起こす可能性があります。

- データベースを開いたり閉じたりすると、リソースが枯渇する可能性があります。
- すべての行を読み取らないか ``rows.Close()`` を使用しないと、プールからの接続が確保されたままになります。
- 行を返さないステートメントに ``Query`` を使用すると、プールからの接続が確保されたままになります。
- `プリペアードステートメント <prepared.html>`_ がどのように動作するかを認識しないと、多くの余分なデータベースアクティビティが発生する可能性があります。

大きな uint64 値
===================

これは驚くべきエラーです。大きなビットが設定されている場合、ステートメントに大きな符号なし整数をパラメーターとして渡すことはできません。

.. code-block:: go

   _, err := db.Exec("INSERT INTO users(id) VALUES", math.MaxUint64) // Error

これはエラーをスローします。 ``uint64`` 値を使用する場合は注意してください。小さな値から始まり、エラーなしで機能しますが、時間の経過とともに増分してエラーをスローし始める可能性があります。

コネクション状態の不一致
=============================

コネクションの状態を変更できるいくつかの操作がありますが、それは次の2つの理由で問題を引き起こす可能性があります。

#. トランザクション内かどうかなどの、一部のコネクションの状態は、Goの型を介して処理する必要があります。
#. クエリが実行されていないときに、クエリが単一の接続で実行されると仮定している場合があります。

たとえば、``USE`` ステートメントを使用して現在のデータベースを設定することは、一般的なことです。 ただし、Goでは、実行中の接続のみに影響します。トランザクション中でない限り、その接続で実行されると思われる他のステートメントは、プールから取得した異なる接続で実際に実行される可能性があるため、そのような変更の影響は見られません。

また、接続を変更すると、プールに戻り、他のコードの状態を潜在的に汚染します。これは ``BEGIN`` または ``COMMIT`` ステートメントをSQLコマンドとして直接発行しないでください理由の1つです。

データベース固有の構文
========================

``database/sql`` のAPIは行指向データベースの抽象化を提供しますが、特定のデータベースとドライバーは、`プリペアドステートメントのプレースホルダー <prepared.html>`_ などの動作や構文が異なる場合があります。

複数のリザルトセット
=======================

Goドライバーは、単一のクエリからの複数のリザルトセットをサポートしていません。バルクコピーなどのバルク操作をサポートするための `機能要求 <https://github.com/golang/go/issues/5171>`_ はありますが、それを行う計画はないようです。

これは、特に、複数のリザルトセットを返すストアドプロシージャが正しく機能しないことを意味します。

ストアドプロシージャの呼び出し
=====================================

ストアドプロシージャの呼び出しはドライバー固有ですが、MySQLドライバーでは現在実行できません。 次のようなものを実行することで、単一のリザルトセットを返す簡単なプロシージャを呼び出すことができるように思えるかもしれません。

.. code-block:: go

   err := db.QueryRow("CALL mydb.myprocedure").Scan(result) // Error

実際、これは機能しません。 次のエラーが表示されます。 *エラー1312* ：プロシージャmydb.myprocedureは、指定されたコンテキストでリザルトセットを返すことができません。 これは、MySQLは、単一の結果であっても、接続がマルチステートメントモードに設定されることを期待しており、ドライバーが現在それを行っていないためです(`この問題 <https://github.com/go-sql-driver/mysql/issues/66>`_ を参照)。

複数ステートメントのサポート
==============================

``database/sql`` は複数のステートメントを明示的にサポートしていません。つまり、この動作はバックエンドに依存しています。

.. code-block:: go

   _, err := db.Exec("DELETE FROM tbl1; DELETE FROM tbl2") // Error/unpredictable result

サーバーは、これを必要に応じて解釈できます。これには、エラーを返す、最初のステートメントのみを実行する、または両方を実行することが含まれます。

同様に、トランザクション内のステートメントをバッチ処理する方法はありません。 トランザクション内の各ステートメントはシリアルで実行する必要があり、単一の行や複数の行などの結果のリソースをスキャンまたは閉じる必要があります。そのため、コネクションは次のステートメントで使用できます。 これは、トランザクションを処理していないときの通常の動作とは異なります。 そのシナリオでは、クエリを実行し、行をループし、ループ内でデータベースへのクエリを作成することが完全に可能です（新しいコネクションで発生します）。

.. code-block:: go

   rows, err := db.Query("select * from tbl1") // Uses connection 1
   for rows.Next() {
       err = rows.Scan(&myvariable)
       // The following line will NOT use connection 1, which is already in-use
       db.Query("select * from tbl2 where id = ?", myvariable)
   }

ただし、トランザクションは1つのコネクションのみにバインドされるため、トランザクションではこれは不可能です。

.. code-block:: go

   tx, err := db.Begin()
   rows, err := tx.Query("select * from tbl1") // Uses tx's connection
   for rows.Next() {
       err = rows.Scan(&myvariable)
       // ERROR! tx's connection is already busy!
       tx.Query("select * from tbl2 where id = ?", myvariable)
   }

ただし、Goを試してみることはできません。 そのため、最初のステートメントがリソースを解放してからクリーンアップする前に別のステートメントを実行しようとすると、コネクションが破損する可能性があります。 これは、トランザクション内の各ステートメントが、データベースへのネットワークラウンドトリップの個別のセットをもたらすことも意味します。

| 前に戻る: `The Connection Pool <connection-pool.html>`_
| 次に進む: `Related Reading and Resources <references.html>`_

.. todo:: 全体的に見直す
